
var Q = require("q");
var moment = require("moment");
var constants = require("x-constants");
var config = require("x-config");
var queue = require("x-queue");
var service = require("x-docServiceProxy");
var db = require('x-db');
var async = require("async");

function run(cb) {
  
  cb = cb || Function;
  console.info('Checking for new papers...');
  
  // 1) Check for new items in queue
  // 2) while queue has items:
  //  2.1) pop item
  //  2.2) download paper with paper id
  //  2.3) parse paper into sentances
  //  2.4) insert each sentance into sentances queue
  
  // Initializing queues
  var queueOutConfig = {
    storageName: config.storage.account,
    storageKey: config.storage.key,
    queueName: config.queues.new_ids,
    visibilityTimeout: config.queue.visibilityTimeoutSecs,
    checkFrequency: config.queue.checkFrequencyMsecs
  };
  var queueInConfig = {
    storageName: config.storage.account,
    storageKey: config.storage.key,
    queueName: config.queues.trigger_query,
    visibilityTimeout: config.queue.visibilityTimeoutSecs,
    checkFrequency: config.queue.checkFrequencyMsecs
  };
  
  var queueOut = queue(queueOutConfig);
  var queueIn = queue(queueInConfig);
  queueIn.init(function (err) {
    if (err) {
      console.error(err);
      return cb(err);
    }
    console.info('start processing trigger queue');
    
    return queueOut.init(function (err) {
      if (err) {
        console.error(err);
        return cb(err);
      }
      console.info('start processing new ids queue');
      return checkQueue();
    });
  });
    
  function checkQueue() {
    console.log('checking queue...');
    queueIn.getSingleMessage(function (err, message) {
      if (err) {
        console.error('error getting message from queue', err);
        return setNextCheck();
      }

      if (!message) {
        return setNextCheck();
      }

      return processMessage(message, function (err) {
        if (err) console.error('error processing message:', message.messageid, err);
        
        // move to the next message
        return checkQueue();
      });
    });
  }

  function setNextCheck() {
    setTimeout(checkQueue, queueInConfig.checkFrequency);
  };
  
  function processMessage(message, cb) {
    console.log('new message', message);
    
    var msgObject;
    try {
      msgObject = JSON.parse(message.messagetext);
    }
    catch (err) {
      console.error('error parsing message, invalid json, deleting...', message);
      return deleteMessage(message);
    }
    
    console.info('found trigger message: ', msgObject);
    var data = msgObject && msgObject.data || {};
    
    if (msgObject.requestType === constants.queues.action.TRIGGER ) {
      return queryNewDocumentIDs(data, function (err) {
        if (err) {
          console.error('error while processing trigger message', err);
          return cb(err);
        }
        return deleteMessage(message, cb);
      });
    }
    else if (msgObject.requestType == constants.queues.action.REPROCESS) {
      console.info('starting documents reprocessing request');
    
      // reprocess all sentences
      var rowCount = 0;
      return db.getDocuments({
          batchSize: config.sql.batchSize,
          rowHandler: rowHandler
        },
        function (err) { 
          if (err) {
            console.error('error while processing reprocessing message', err);
            return cb(err);
          }
          console.info('reprocessing request deleted from queue, %s documents sent for reprocessing', rowCount);
          return deleteMessage(message, cb);
      });
      
      function rowHandler(row) {
        rowCount++;
        var doc = {
          docId: row.Id,
          sourceId: row.SourceId
        };
        return enqueueDocument(doc, function(err){
          if (err) return cb(err);
        });
      }
    }
    else {
      console.error('message type is not expected, deleting', msgObject);
    }
    
    function deleteMessage(message) {
      return queueIn.deleteMessage(message, function (err) {
        if (err) return cb(new Error('error deleting item from queue', err));
        console.log('item deleted from queue', message.messageid);
        return cb();
      });
    }
  }
  
  function queryNewDocumentIDs(data, cb) {
    // Checking that a message returned from the queue
    // if no message was returned, the queue is empty
    var toDate = data.to ? moment(data.to) : moment();
    var fromDate = data.from ? moment(data.from) : moment().add(-3, 'days'); // TODO: change to 0 days (only today)
    console.info('getting papers from %s to %s', fromDate.format('YYYY-MM-DD'), toDate.format('YYYY-MM-DD'));
    
    // Run query for document in specific date
    return service.getPapers(fromDate.toDate(), toDate.toDate(), function (err, documents) {
      if (err) {
        console.error('There were several errors while retrieving the papers.');
        return cb(err);
      }
      
      if (!documents || !Array.isArray(documents)) {
        console.warning('Returned data is not an array');
        return cb();
      }
      
      console.info('Found %s new documents', documents.length);
      
      // Queue all new document ids
      async.each(documents, enqueueDocument, function (err) {
        if (err) {
          console.error('failed to queue messages for documents.');
          return cb(err);
        }
        
        // Test Dependency:
        // The following message is used as part of E2E testing
        console.info('done queuing messages for all documents');
        return cb();
      });
      
      return console.info('Completed iterating through retrieved documents, waiting for results to complete...');
    });
  }
  
  function enqueueDocument(doc, cb) {
    var message = {
      requestType: constants.queues.action.GET_DOCUMENT,
      data: {
        docId: doc.docId,
        sourceId: doc.sourceId
      }
    };
    
    return queueOut.sendMessage(message, function (err) {
      if (err) {
        console.error('There was an error queuing a document.');
        return cb(err);
      }
      
      // Test Dependency:
      // The following message is used as part of E2E testing
      console.log('Queued document %s from source %s', doc.docId, doc.sourceId)
      return cb();
    });
  }
}

module.exports = {
  run: run
};