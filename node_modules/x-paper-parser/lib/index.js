var Q = require("q");
var constants = require("x-constants");
var config = require("x-config");
var queue = require("x-queue");
var service = require("x-docServiceProxy");
var async = require("async");
var db = require("x-db")

function run(callback) {
    
    callback = callback || Function;
      
    console.info('Checking for new papers...');
    
    // 1) Check for new items in queue
    // 2) while queue has items:
    //  2.1) pop item
    //  2.2) download paper with paper id
    //  2.3) parse paper into sentances
    //  2.4) insert each sentance into sentances queue
    
    // Initializing queues
    var queueInConfig = {
      storageName: config.storage.account,
      storageKey: config.storage.key,
      queueName: config.queues.new_ids,
      visibilityTimeout: config.queue.visibilityTimeoutSecs,
      checkFrequency: config.queue.checkFrequencyMsecs
    };
    var queueOutConfig = {
      storageName: config.storage.account,
      storageKey: config.storage.key,
      queueName: config.queues.scoring,
      visibilityTimeout: config.queue.visibilityTimeoutSecs,
      checkFrequency: config.queue.checkFrequencyMsecs
    };
    
    var queueIn = queue(queueInConfig);
    var queueOut = queue(queueOutConfig);
    
    queueOut.init(function (err) {
      if (err) {
        console.error(err);
        return callback(err);
      }
      console.info('start processing scoring queue');
      
      return queueIn.init(function (err) {
        if (err) {
          console.error(err);
          return callback(err);
        }
        console.info('start processing new ids queue');
        checkQueue();
      });
    });
      
    function checkQueue() {
      console.log('checking queue...');
      queueIn.getSingleMessage(function (err, message) {
        if (err) {
          console.error('error getting message from queue', err);
          return setNextCheck();
        }

        if (!message) {
          return setNextCheck();
        }

        return processMessage(message, function (err) {
          if (err) console.error('error processing message:', message.messageid, err);
          
          // move to the next message
          return checkQueue();
        });
      });
    }

    function setNextCheck() {
      setTimeout(checkQueue, queueInConfig.checkFrequency);
    };
      
     
    function processMessage(message, cb) {

      var msgObject;
      try {
        msgObject = JSON.parse(message.messagetext);
      }
      catch (err) {
        console.error('error parsing message, invalid json, deleting...', message);
        return deleteMessage(message);
      }

      var data = msgObject && msgObject.data;
      var docId = parseInt(data.docId);
      var sourceId = data.sourceId;
      
      if (sourceId !== constants.sources.PMC) {
          console.info('Skipping message processing, since it is not PMC source');
          return deleteMessage(message);
      }
      
      console.info("Processing document id %s from %s...", docId, sourceId);
      
      // Add a "Processing" status to document
      return db.upsertDocument({
        sourceId: sourceId,
        docId: docId,
        statusId: constants.documentStatus.PROCESSING    
        }, function (err, result) {
          
          if (err) {
              console.error('There was an error inserting document row into database.');
              return cb(err);
          }
          
          // PMC: getting sentences of document from PMC service (TODO: extend for pubmed)
          console.log('Searching for sentences...');
          // sample in the samples folder from here: http://104.197.190.17/doc/pmc/2000354
          return service.getDocumentSentences(docId, sourceId, function (err, sentencesArray) {
              if (err) {
                console.error(err);
                
                if (err.errorCode == service.ERRORS.NOT_ACCESSIBLE) {
                  // the document is not accessible, no point in retrying.
                  // we should delete it from the queue
                  
                  // mark status as NOT ACCESSIBLE in the DB
                  var updateStatusOpts = {
                    sourceId: data.sourceId,
                    docId: data.docId,
                    statusId: constants.documentStatus.NOT_ACCESSIBLE
                  };
                  return db.updateDocumentStatus(updateStatusOpts, function (err) { 
                    if (err) {
                      console.error('error updating document status in db', updateStatusOpts, err);
                      return cb(err);
                    }
                    
                    // delete message from queue
                    console.warn('document is not accessible, deleting item', message);
                    return deleteMessage(message);
                  });
                }
                  
                return cb(err);
              }
              
              // filter out sentences with no mirna and genes,
              // normalize mention schemas (workaround until Giovanny fixes his code)
              // remove duplicate mentions
              // capture sentence index in the array
              var sentences = sentencesArray.sentences
                .filter(function (sentence) { 
                  //var cache = {};
                  var entities = sentence.mentions
                    // fix entities data
                    .map(function (mention) {
                      // this is a workaround, waiting for Giovanney to fix
                      if (typeof mention.value !== 'string') mention.value = mention.value.mirna || mention.value.origin || 'aaaaa';
                      mention.type = mention.type.toLowerCase(); 
                      return mention;
                    })
                    /*
                    // filter multiple instance of the same mentions
                    .filter(function (entity) {
                      var key = entity.type + '-' + entity.id;
                      if (!cache[key]) {
                        cache[key] = 1;
                        return entity;
                      }
                      return null;
                    })*/;
                    
                
                  // check that we have at least one mirna and one gene
                  var genes = entities.filter(function (mention) {
                    return mention.type === constants.entitiesName.GENE ? mention : null;
                  });

                  var mirnas = entities.filter(function (mention) {
                    return mention.type === constants.entitiesName.MIRNA ? mention : null;
                  });
                  
                  // filter out sentences with no mirna and genes,
                  if (!genes.length || !mirnas.length) {
                    console.log('filtering out a sentence with no mirna and gene', sentence);
                    return null;
                  }
                    
                  return sentence; 
                })
                // capture sentence index in the array
                .map(function (sentence, index) {
                  return { data: sentence, index: index };
              });
              
              console.info('Found %s relevant sentences for scoring', sentences.length);
              
              // Asynchronously queuing all sentences in current document
              return async.each(sentences, processSentence, function (err) {
                  if (err) {
                      console.error(err);
                      return cb(err);
                  }
                  
                  // Test Dependency:
                  // The following message is used as part of E2E testing
                  console.info('done queuing messages for document <%s>', docId);

                  // send a last item to the queue to mark that
                  // the processing of this document is done 
                  var msg = {
                    requestType: constants.queues.action.LAST_ITEM_TO_SCORE,
                    data: {
                      sourceId: data.sourceId,
                      docId: docId  
                    }
                  };
                  return queueOut.sendMessage(msg, function (err) {
                    if (err) return cb(err);
                      
                    console.log('Queued last item mark');
                  
                    // update document status to SCORING
                    return db.updateDocumentStatus({
                      sourceId: sourceId,
                      docId: docId,
                      statusId: constants.documentStatus.SCORING
                    }, function (err) { 
                      if (err)  return cb(err);
                      return deleteMessage(message);
                    });  
                  });
              });
              
              function processSentence(sentence, cb) {
                var message = {
                  requestType: constants.queues.action.SCORE,
                  data: {
                    sourceId: data.sourceId,
                    docId: docId,
                    sentenceIndex: sentence.index,
                    sentence: sentence.data.sentence,
                    mentions: sentence.data.mentions
                  }
                };
                  
                return queueOut.sendMessage(message, function (err) {
                    if (err) {
                        console.error('failed to queue message: <%s> of paper <%s>', message, docId);
                        return cb(err);
                    }
                    
                    console.info('Queued sentence %s in document %s from source %s', sentence.index, docId, data.sourceId)
                    return cb();
                });
              }
          });
      });
      
        function deleteMessage(message) {
        return queueIn.deleteMessage(message, function (err) {
          if (err) return cb(new Error('error deleting item from queue', err));
          console.log('item deleted from queue', message.messageid);
          return cb();
        });
      }
    }
}

module.exports = {
    run: run
};