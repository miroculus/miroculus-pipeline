var constants = require("x-constants");

/**
  * Get a text from a full document at return an array of sentences
  * Todo: This should be turned to a query to giovanny's API 
  * 
  * @param   {string}      [text] - Text to parse
  * @returns {string[]}           - sentences array
  */
function turnTextToSentences (text) {
    return text.match(/\S.*?\."?(?=\s|$)/g);
}

/**
  * Create a queue sentence message
  * Todo: should add relations array 
  * 
  * @param   {object}     [opts]  - Text to parse
  * @param   {string}     [opts.sourceId]  - Text to parse
  * @param   {string}     [opts.docId]     - Text to parse
  * @param   {string}     [opts.index]     - Text to parse
  * @param   {string}     [opts.sentence]  - Text to parse
  * @param   {object[]}   [opts.relations] - Text to parse
  * @returns {object}                 - queue message
  */
function createQueueSentenceMessage(opts) {
  
  var sourceId = opts.sourceId;
  var docId = opts.docId;
  var index = opts.index;
  var sentence = opts.sentence;
  var relations = opts.relations;
  
  return {
    requestType: constants.queues.action.SCORE,
    data: {
      sourceId: sourceId,
      docId: docId,
      sentenceIndex: index,
      modelVersion: constants.queues.modelVersion,
      sentence: sentence,
      relations: [
        {
          entity1: {
            typeId: constants.conceptTypes.MIRNA,
            name: "mirnaX"
          },
          entity2: {
            typeId: constants.conceptTypes.GENE,
            name: "geneY"
          },
          relation: 2,
          score: 0.56
        },
        {
          entity1: {
            typeId: constants.conceptTypes.MIRNA,
            name: "mirnaX2"
          },
          entity2: {
            typeId: constants.conceptTypes.GENE,
            name: "geneY2"
          },
          relation: 1,
          score: 0.57
        }
      ]
    }
  };
}

module.exports = {
  turnTextToSentences: turnTextToSentences,
    createQueueSentenceMessage: createQueueSentenceMessage
};