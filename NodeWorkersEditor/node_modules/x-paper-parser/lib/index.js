var Q = require("q");
var constants = require("x-constants");
var config = require("x-config");
var queue = require("x-queue");
var service = require("x-docServiceProxy");
var async = require("async");
var parserUtils = require("./parserUtils.js");
var db = require("x-db")

var log = require('x-log');
var APP_NAME = 'paper-parser';


function run(callback) {
    
    callback = callback || Function;
    
    log.init({
        domain: process.env.COMPUTERNAME || '',
        instanceId: log.getInstanceId(),
        app: APP_NAME,
        level: config.log.level,
        transporters: config.log.transporters
    }, function (err) {
        if (err) return callback(new Error('Failed to initialize logging, err:', err));
        
        
        console.info('====================================================');
        console.info('Checking for new papers...');
        console.info('====================================================');
        
        // 1) Check for new items in queue
        // 2) while queue has items:
        //  2.1) pop item
        //  2.2) download paper with paper id
        //  2.3) parse paper into sentances
        //  2.4) insert each sentance into sentances queue
        
        // Initializing queues
        var queueInConfig = {
            storageName: config.storage.account,
            storageKey: config.storage.key,
            queueName: config.queues.new_ids,
            checkFrequency: 1000
        };
        var queueOutConfig = {
            storageName: config.storage.account,
            storageKey: config.storage.key,
            queueName: config.queues.scoring,
            checkFrequency: 1000
        };
        
        var queueIn = queue(queueInConfig);
        var queueOut = queue(queueOutConfig);
        
        queueOut.init(function (err) {
            if (err) {
                console.error(err);
                return callback(err);
            }
            console.info('start processing scoring queue');
            
            return queueIn.init(function (err) {
                if (err) {
                    console.error(err);
                    return callback(err);
                }
                console.info('start processing new ids queue');
                
                checkQueue();
            });
        });
        
        function checkQueue() {
            console.info("Querying for next message in queue");
            queueIn.getSingleMessage(function (err, message) {
                if (err) {
                    console.error(err);
                    
                    // Retry in a while
                    return setNextCheck();
                }
                console.info('Start processing message from queue...');
                
                processMessage(message, function (err) {
                    if (err) console.error(err);
                    
                    return setNextCheck();
                });
            });
        }
        
        function processMessage(message, cb) {
            
            // Checking that a message returned from the queue
            // if no message was returned, the queue is empty
            if (!message) { cb(); }
            
            var fields = constants.queues.fields;
            var messageDetails;
            try {
                JSON.parse(message.messagetext);
            } catch (e) {
                console.error('error parsing json', message, e);
                return cb(e);
            }
            var messageData = messageDetails.data;
            var docId = messageData.docId;
            var source = messageData.sourceId == constants.sources.PMC ? 'pmc' : 'pubmed'; //TODO
            
            if (messageData.sourceId != constants.sources.PMC) {
                console.info('Skipping message processing, since it is not PMC source');
                return cb(null);
            }
            
            console.info("Processing document id {} from {}...", docId, source);
            
            // Add a "Processing" status to document
            return db.upsertDocument(docId, '', messageData.sourceId, function (err, result) {
                
                if (err) {
                    console.error('There was an error inserting document row into database.');
                    return cb(err);
                }
                
                // PMC: getting sentences of document from PMC service (TODO: extend for pubmed)
                return service.getDocumentSentences(docId, source, function (err, sentences) {
                    
                    if (err) {
                        console.error(err);
                        return cb(err);
                    }
                    
                    console.info('Found %s sentences', sentences && sentences.length || 0);
                    
                    // Asynchronously queuing all sentences in current document
                    return async.each(sentences, processSentence, function (err) {
                        
                        if (err) {
                            console.error(err);
                            return cb(err);
                        }
                        
                        console.info('done queuing messages for document <{}>', docId);
                        
                        // delete message from queue
                        return queueIn.deleteMessage(message).then(function (err) {
                            if (err) {
                                console.error('error deleting item from queue {}', err);
                                return cb(err);
                            }
                            
                            console.info('item deleted from queue');
                            return cb();
                        });
                    });
                    
                    /**
            * This method is used to process each sentence returned from the document.
            */
          function processSentence(sentence, cb) {
                        var index = sentences.indexOf(sentence);
                        
                        var outMessage = parserUtils.createQueueSentenceMessage({ sourceId: messageData.sourceId, docId: docId, index: index, sentence: sentence });
                        
                        return queueOut.sendMessage(outMessage, function (err) {
                            
                            if (err) {
                                console.error('failed to queue message: <{}> of paper <{}>', sentense, docId);
                                return cb(err);
                            }
                            
                            console.info('Queued sentence {} in document {} from source {}', index, docId, messageData.sourceId)
                            return cb();
                        });
                    }
                });
            });
        }
        
        function setNextCheck() {
            console.info('Setting next check in {} milliseconds', queueInConfig.checkFrequency);
            return setTimeout(checkQueue, queueInConfig.checkFrequency);
        }
    });
}

module.exports = {
    run: run
};