var Q = require("q");
var constants = require("x-constants");
var config = require("x-config");
var queue = require("x-queue");
var service = require("./docServiceProxy");
var async = require("async");
var parserUtils = require("./parserUtils");
var db = require("x-db")

var log = require('x-log');
var APP_NAME = 'paper-parser';

function run(callback) {
    
    callback = callback || Function;
    
    log.init({
        domain: process.env.COMPUTERNAME || '',
        instanceId: log.getInstanceId(),
        app: APP_NAME,
        level: config.log.level,
        transporters: config.log.transporters
    }, function (err) {
        if (err) return callback(new Error('Failed to initialize logging, err:', err));
        
        
        console.info('====================================================');
        console.info('Checking for new papers...');
        console.info('====================================================');
        
        // 1) Check for new items in queue
        // 2) while queue has items:
        //  2.1) pop item
        //  2.2) download paper with paper id
        //  2.3) parse paper into sentances
        //  2.4) insert each sentance into sentances queue
        
        // Initializing queues
        var queueInConfig = {
            storageName: config.storage.account,
            storageKey: config.storage.key,
            queueName: config.queues.new_ids,
            checkFrequency: 1000
        };
        var queueOutConfig = {
            storageName: config.storage.account,
            storageKey: config.storage.key,
            queueName: config.queues.scoring,
            checkFrequency: 1000
        };
        
        var queueIn = queue(queueInConfig);
        var queueOut = queue(queueOutConfig);
        
        queueOut.init(function (err) {
            if (err) {
                console.error(err);
                return callback(err);
            }
            console.info('start processing scoring queue');
            
            return queueIn.init(function (err) {
                if (err) {
                    console.error(err);
                    return callback(err);
                }
                console.info('start processing new ids queue');
                
                checkQueue();
            });
        });
        
        function checkQueue() {
            console.info("Querying for next message in queue");
            queueIn.getSingleMessage(function (err, message) {
                if (err) {
                    console.error(err);
                    
                    // Retry in a while
                    return setNextCheck();
                }
                console.info('Start processing message from queue...');
                
                processMessage(message, function (err) {
                    if (err) console.error(err);
                    
                    return setNextCheck();
                });
            });
        }
        
        function processMessage(message, cb) {
            
            // Checking that a message returned from the queue
            // if no message was returned, the queue is empty
            if (!message) { return cb(); }
            
            var messageDetails;
            try {
                messageDetails = JSON.parse(message.messagetext);
            } catch (err) {
                console.error('error parsing json', message, err);
                return cb(err);
            }
            var messageData = messageDetails.data;
            var docId = parseInt(messageData.docId);
            var sourceId = messageData.sourceId;
            
            if (sourceId !== constants.sources.PMC) {
                console.info('Skipping message processing, since it is not PMC source');
                return cb();
            }
            
            console.info("Processing document id %s from %s...", docId, sourceId);
            
            // Add a "Processing" status to document
            return db.upsertDocument({
              sourceId: sourceId,
              docId: docId,
              statusId: constants.documentStatus.PROCESSING    
              }, function (err, result) {
                
                if (err) {
                    console.error('There was an error inserting document row into database.');
                    return cb(err);
                }
                
                // PMC: getting sentences of document from PMC service (TODO: extend for pubmed)
                console.log('Searching for sentences...');
                return service.getDocumentSentences(docId, sourceId, function (err, sentencesArray) {
                    if (err) {
                      console.error(err);
                      
                      if (err.errorCode == service.ERRORS.NOT_ACCESSIBLE) {
                        // the document is not accessible, no point in retrying.
                        // we should delete it from the queue
                        
                        // mark status as NOT ACCESSIBLE in the DB
                        var updateStatusOpts = {
                          sourceId: messageData.sourceId,
                          docId: messageData.docId,
                          statusId: constants.documentStatus.NOT_ACCESSIBLE
                        };
                        return db.updateDocumentStatus(updateStatusOpts, function (err) { 
                          if (err) {
                            console.error('error updating document status in db', updateStatusOpts, err);
                            return cb(err);
                          }
                          
                          // delete message from queue
                          console.warn('document is not accessible, deleting item', message);
                          return queueIn.deleteMessage(message, function (err) {
                              if (err) {
                                  console.error('error deleting item from queue %s', err);
                                  return cb(err);
                              }
                              
                              console.info('item deleted from queue');
                              return cb();
                          });
                        });
                      }
                        
                      return cb(err);
                    }
                    
                    var sentences = sentencesArray.sentences.map(function (sentence, index) {
                      return { text: sentence, index: index };
                    });
                    
                    console.info('Found %s sentences', sentences.length);
                    
                    // Asynchronously queuing all sentences in current document
                    return async.each(sentences, processSentence, function (err) {
                        if (err) {
                            console.error(err);
                            return cb(err);
                        }
                        
                        // Test Dependency:
                        // The following message is used as part of E2E testing
                        console.info('done queuing messages for document <%s>', docId);

                        // send a last item to the queue to mark that
                        // the processing of this document is done 
                        var msg = {
                          requestType: constants.queues.action.LAST_ITEM_TO_SCORE,
                          data: {
                            sourceId: messageData.sourceId,
                            docId: docId  
                          }
                        };
                        return queueOut.sendMessage(msg, function (err) {
                          if (err) return cb(err);
                            
                          console.log('Queued last item mark');
                        
                          // update document status to SCORING
                          return db.updateDocumentStatus({
                            sourceId: sourceId,
                            docId: docId,
                            statusId: constants.documentStatus.SCORING
                          }, function (err) { 
                            if (err)  return cb(err);
                          
                            // delete message from queue
                            return queueIn.deleteMessage(message, function (err) {
                              if (err) {
                                console.error('error deleting item from queue %s', err);
                                return cb(err);
                              }

                              console.info('item deleted from queue');
                              return cb();
                            });
                          });  
                        });
                    });
                    
                    /**
                    * This method is used to process each sentence returned from the document.
                    */
                    function processSentence(sentence, cb) {
                        var index = sentence.index;
                        var outMessage = parserUtils.createQueueSentenceMessage({ 
                          sourceId: messageData.sourceId, 
                          docId: docId, 
                          index: index, 
                          sentenceData: sentence.text
                        });
                        
                        return queueOut.sendMessage(outMessage, function (err) {
                            if (err) {
                                console.error('failed to queue message: <%s> of paper <%s>', outMessage, docId);
                                return cb(err);
                            }
                            
                            console.info('Queued sentence %s in document %s from source %s', index, docId, messageData.sourceId)
                            return cb();
                        });
                    }
                });
            });
        }
        
        function setNextCheck() {
            console.info('Setting next check in %s milliseconds', queueInConfig.checkFrequency);
            return setTimeout(checkQueue, queueInConfig.checkFrequency);
        }
    });
}

module.exports = {
    run: run
};