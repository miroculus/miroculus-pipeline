var tedious = require('tedious');
var Connection = tedious.Connection;
var ConnectionPool = require('tedious-connection-pool');
var Request = tedious.Request;
var TYPES = tedious.TYPES;
var constants = require("x-constants");
var configSql = require('x-config').sql;

var DBErrors = {
    duplicate: 2601
}

// TODO: move to configuration
var poolConfig = {
    min: 2,
    max: 5,
    idleTimeout: 10000,
    log: false
};

var pool = new ConnectionPool(poolConfig, configSql);
pool.on('error', function (err) {
  console.error('error connecting to sql', err);
});

function logError(err, connection, cb) {
  console.error('error:', err);
  console.log('releasing connection');
  if (connection) connection.release();
  return cb(err);
}

function connect(cb) {
  return pool.acquire(cb);
}

function getCloseConnectionCb(connection, cb) {
  return function () {
    connection.release();
    return cb.apply(null, arguments);
  }
}

function upsertRelations(opts, cb) {
  
  console.log('upserting relation', opts);
  
  return connect(function (err, connection) {
    if (err) return logError(err, connection, cb);
    
    var request = new tedious.Request('UpsertRelation', getCloseConnectionCb(connection, cb));
    
    request.addParameter('SourceId', TYPES.VarChar, opts.sourceId);
    request.addParameter('DocId', TYPES.VarChar, opts.docId);
    request.addParameter('SentenceIndex', TYPES.Int, opts.sentenceIndex);
    request.addParameter('ModelVersion', TYPES.VarChar, opts.modelVersion);
    request.addParameter('Sentence', TYPES.Text, opts.sentence);
        
    // entities
    var entitiesTable = {
      columns: [
        { name: 'TypeId', type: TYPES.Int },
        { name: 'Id', type: TYPES.Int },
        { name: 'Name', type: TYPES.VarChar }
      ],
      rows: []
    };

    var entities = opts.entities || [];
    for (var i=0; i < entities.length; i++) {
      var entity = entities[i];
      entitiesTable.rows.push([
        entity.typeId,
        entity.id,
        entity.name
      ]);
    }
    request.addParameter('entities', TYPES.TVP, entitiesTable);
    
    // relations
    var relationsTable = {
      columns: [
        { name: 'Entity1TypeId', type: TYPES.Int },
        { name: 'Entity1Id', type: TYPES.Int },
        { name: 'Entity2TypeId', type: TYPES.Int },
        { name: 'Entity2Id', type: TYPES.Int },
        { name: 'Relation', type: TYPES.Int },
        { name: 'Score', type: TYPES.Real }
      ],
      rows: []
    };

    var relations = opts.relations || [];
    for (var i=0; i < relations.length; i++) {
      var relation = relations[i];
      relationsTable.rows.push([
        relation.entity1.typeId,
        relation.entity1.id,
        relation.entity2.typeId,
        relation.entity2.id,
        relation.relation,
        relation.score
      ]);
    }
    request.addParameter('relations', TYPES.TVP, relationsTable);
    
    request.on('returnValue', function (parameterName, value, metadata) {
      console.log('returnValue {}', parameterName + ' = ' + value);
    });
    
    return connection.callProcedure(request);
  });
}

function getDataSets(opts, cb) {
  return connect(function(err, connection){
    if (err) return logError(err, connection, cb);

    var sproc = opts.sproc,
      sets = opts.sets,
      params = opts.params,
      currSetIndex = -1;

    var result = {};

    var request = new tedious.Request(sproc, function(err, rowCount, rows) {
      if (err) return logError(err, connection, cb);
    });

    for (var i=0; i<params.length; i++) {
      var param = params[i];
      request.addParameter(param.name, param.type, param.value);
    }

    request.on('columnMetadata', function (columns) {
      currSetIndex++;
      result[sets[currSetIndex]] = [];
    });

    request.on('row', function (columns) {
      var rowObj = {};
      for(var i=0; i<columns.length; i++) {
          rowObj[columns[i].metadata.colName] = columns[i].value;
      }
      result[sets[currSetIndex]].push(rowObj);
    });

    request.on('doneProc', function (rowCount, more, returnStatus, rows) {
      getCloseConnectionCb(connection, cb)(null, result);
    });

    return connection.callProcedure(request);
  });
}

/*
req: {
    docs: [
        {
            sourceId: 1,
            docId: 'AAA'
        }
    ]
}
*/
function getUnprocessedDocuments(req, cb) {

    var table = {
        columns: [
            {name: 'SourceId', type: TYPES.Int},
            {name: 'DocId', type: TYPES.VarChar}
        ],
        rows: []
    };

    for (var i =0; i < req.docs.length; i++) {
        var doc = req.docs[i];
        table.rows.push([doc.sourceId, doc.docId]);
    }

    var params = [
        { name: 'Docs', type: TYPES.TVP, value: table }
    ];
    
    return getDataSets({
        sproc: 'FilterExistingDocuments',
        sets: ['docs'],
        params: params
    }, function(err, result) {
        if (err) return logError(err, null, cb);

        return cb(null, result);
    });
} 

/**
* Upload a document's content to the sql database and insert a new row to orepresent it
* 
* @param {string}      [paperId]       The id of the paper to insert
* @param {string}      [paperName]     The web source for the document
* @param {string}      [paperSouce]    The web source for the document
* @param {function}    [callback]      Callback for when the upsert was completed
*/
function upsertDocument(docId, docName, sourceId, callback) {
    
    console.log('sending id %s source %s to db', docId, sourceId);
    return getDataSets({
        sproc: 'UpsertDocument',
        sets: ['data'],
        params: [
            { name: 'Id', type: TYPES.VarChar, value: docId },
            { name: 'Description', type: TYPES.VarChar, value: docName },
            { name: 'SourceId', type: TYPES.Int, value: sourceId },
            { name: 'StatusId', type: TYPES.Int, value: constants.documentStatus.PROCESSING },
        ]
    }, 
    function (err, result) {
        if (err) return callback(err);
        return callback(null, result);
    });
}


function updateDocumentStatus(opts, cb) {
  console.log('UpdateDocumentStatus', opts);
  return connect(function (err, connection) {
    if (err) return logError(err, connection, cb);
    
    var request = new tedious.Request('UpdateDocumentStatus', getCloseConnectionCb(connection, cb));
    
    request.addParameter('SourceId', TYPES.VarChar, opts.sourceId);
    request.addParameter('DocId', TYPES.VarChar, opts.docId);
    request.addParameter('StatusId', TYPES.Int, opts.statusId);
    
    console.log('calling UpdateDocumentStatus with', opts, request);
    return connection.callProcedure(request);
  });
}


module.exports = {
  connect: connect,
  getDataSets: getDataSets,
  upsertRelations: upsertRelations,
  getUnprocessedDocuments: getUnprocessedDocuments,
  upsertDocument: upsertDocument,
  updateDocumentStatus: updateDocumentStatus
}