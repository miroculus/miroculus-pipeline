
var Q = require("q");
var moment = require("moment");
var constants = require("x-constants");
var config = require("x-config");
var queue = require("x-queue");
var service = require("x-docServiceProxy");
var async = require("async");
var log = require('x-log');

var APP_NAME = 'doc-query';


function run(callback) {

    callback = callback || Function;

    log.init({
        domain: process.env.COMPUTERNAME || '',
        instanceId: log.getInstanceId(),
        app: APP_NAME,
        level: config.log.level,
        transporters: config.log.transporters
    }, function (err) {
        if (err) return callback(new Error('Failed to initialize logging, err:', err));

        console.info('====================================================');
        console.info('Checking for new papers...');
        console.info('====================================================');

        // 1) Check for new items in queue
        // 2) while queue has items:
        //  2.1) pop item
        //  2.2) download paper with paper id
        //  2.3) parse paper into sentances
        //  2.4) insert each sentance into sentances queue

        // Initializing queues
        var queueOutConfig = {
            storageName: config.storage.account,
            storageKey: config.storage.key,
            queueName: config.queues.new_ids,
            checkFrequency: 5000 /* every 5 seconds */
        };
        var queueOut = queue(queueOutConfig);
        queueOut.init(function (err) {
            if (err) {
                console.error(err);
                return callback(err);
            }
            console.info('start processing new ids queue');
            return checkForNewDocuments();
        });

        function checkForNewDocuments() {
            return queryNewDocumentIDs(function (err) {
               if (err) console.error(err);

               return setNextCheck();
            });
        }

        function queryNewDocumentIDs(cb) {

            // Checking that a message returned from the queue
            // if no message was returned, the queue is empty
            var toDate = moment();
            var fromDate = moment().add(-3, 'days'); // TODO: change to 0 days (only today)
            console.info('getting papers from {} to {}', fromDate.format('YYYY-MM-DD'), toDate.format('YYYY-MM-DD'));

            // Run query for document in specific date
            return service.getPapers(fromDate.toDate(), toDate.toDate(), function (error, documents) {
                if (error) {
                    console.error('There were several errors while retrieving the papers.');
                    return cb(error);
                }

                if (!documents || !Array.isArray(documents)) {
                    console.warning('Returned data is not an array');
                    return cb();
                }

                console.info('Found {} new documents', documents.length);
                console.info('Queuing documents...');

                // Queue all new document ids
                async.each(documents, enqueueDocument, function (err) {
                    if (err) {
                        console.error('failed to queue messages for documents.');
                        return cb(err);
                    }

                    console.info('done queuing messages for all documents');
                    return cb();
                });

                return console.info('Completed iterating through retrieved documents, waiting for results to complete...');

                // Queuing each document as a pending request for processing
                function enqueueDocument(doc, cb) {
                    var message = {
                        "requestType": constants.queues.action.GET_DOCUMENT,
                        "data": {
                            "docId": doc.docId,
                            "sourceId": doc.sourceId
                        }
                    };

                    return queueOut.sendMessage(message, function (err) {
                        if (error) {
                            console.error('There was an error queuing a document.');
                            return cb(err);
                        }

                        console.info('Queued document %s from source %s', doc.docId, doc.sourceId)
                        return cb();
                    });
                }
            });
        }

        function setNextCheck () {
            console.info('Setting next check in {} milliseconds', queueOutConfig.checkFrequency);
            setTimeout(checkForNewDocuments, queueOutConfig.checkFrequency);
        }
    });
}

module.exports = {
    run: run
};