
var config = require('x-config');
var log = require('x-log');
var path = require('path');
var tedious = require('tedious');
var config = require('x-config');
var queue = require('x-queue');
var db = require('x-db');
var constants = require('x-constants');

var APP_NAME = 'scorer';

function run(cb) {
  cb = cb || Function;

  log.init({
      domain: process.env.COMPUTERNAME || '',
      instanceId: log.getInstanceId(),
      app: APP_NAME,
      level: config.log.level,
      transporters: config.log.transporters
    },
    function (err) {
      if (err) return cb(new Error('Failed to initialize logging, err:', err));
      console.log('starting scoring worker...');

      var queueConfig = {
        storageName: config.storage.account,
        storageKey: config.storage.key,
        queueName: config.queues.scoring,
        checkFrequency: 20000
      };

      var queueIn = queue(queueConfig);
      queueIn.init(function (err) { 
        if (err) return cb(err);
        console.log('start processing scoring queue');
        checkQueue();
      });

      function checkQueue() {
        console.log('checking queue...');
        queueIn.getSingleMessage(function (err, message) {
          if (err) {
            console.error('error getting message from queue', err);
            return setNextCheck();
          }

          if (!message) {
            return setNextCheck();
          }

          return processMessage(message, function (err) {
            if (err) console.error('error processing message:', message.messageid, err);
            
            // move to the next message
            return checkQueue();  
          });
        });
      }
      
      function setNextCheck() {
        setTimeout(checkQueue, queueConfig.checkFrequency);
      };

      function processMessage(message, cb) {
        console.log('new message', message);

        var msgObject;
        try {
          msgObject = JSON.parse(message.messagetext);
        }
        catch (err) {
          console.error('error parsing message, invalid json, deleting...', message);
          return deleteMessage(message);
        } 

        var data = msgObject.data && msgObject.data;
        if (!data) {
          console.error('message does not contain data field, deleting...', message);
          return deleteMessage(message);
        }
        
        if (msgObject.requestType !== constants.queues.action.SCORE) {
          console.error('message should not appear in this queue, deleting...', message);
          return deleteMessage(message);
        }
        
        if (msgObject.requestType === constants.queues.action.SCORE) {

          var score = [0.3, 0.4, 0.2, 0.1]; // call score here
          console.log('score for messageid', message.messageid, score);

          return getScoring(score, function (err, res) {
            // if we had an error getting the scoring for the message,
            // we'll return and hopefully the message will be scored the next
            // time we try...
            if (err) {
              console.error('error getting scoring for message', err);
              return cb(err);
            }
            
            console.log('got scoring relation:', res);
            data.scoring = res;
            
            // insert relation into db
            return db.upsertRelations(data, function (err) {

              // if we had error inserting into db, we don't want to delete from the queue,
              // just return and hopefully the next iteration will work.
              // the item will stay in the queue until it will be processed.
              if (err) {
                console.error('error updating relation in db', err)
                return cb(err);
              }
              
              // ite, was processed and saved in db successfully- delete from queue
              return deleteMessage(message, cb);
            });  
          });
          
        }
        
        function deleteMessage(message) {
          return queueIn.deleteMessage(message, function (err) { 
            if (err) return cb(new Error('error deleting item from queue', err));
            console.log('item deleted from queue', message.messageid);
            return cb();
          });
        }
      };

      // TODO: revisit after Justin publishes his API
      function getScoring(scoring, cb) {
        var index = 0;
        var score = 0;
        for (var i = 0; i < scoring.length; i++) {
          if (parseFloat(scoring[i]) > score) {
            score = parseFloat(scoring[i]);
            index = i;
          }
        }

        return cb(null, {
          score: score,
          relation: index + 1
        });
      }
    });
}

module.exports = {
    run: run
}