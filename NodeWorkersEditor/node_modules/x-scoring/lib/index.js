
var async = require('async');
var request = require('request')
var config = require('x-config');
var log = require('x-log');
var path = require('path');
var tedious = require('tedious');
var config = require('x-config');
var queue = require('x-queue');
var db = require('x-db');
var constants = require('x-constants');

var APP_NAME = 'scorer';

function run(cb) {
  cb = cb || Function;

  log.init({
      domain: process.env.COMPUTERNAME || '',
      instanceId: log.getInstanceId(),
      app: APP_NAME,
      level: config.log.level,
      transporters: config.log.transporters
    },
    function (err) {
      if (err) return cb(new Error('Failed to initialize logging, err:', err));
      console.log('starting scoring worker...');

      var queueConfig = {
        storageName: config.storage.account,
        storageKey: config.storage.key,
        queueName: config.queues.scoring,
        checkFrequency: 20000
      };

      var queueIn = queue(queueConfig);
      queueIn.init(function (err) { 
        if (err) return cb(err);
        console.log('start processing scoring queue');
        checkQueue();
      });


      
      /* 
      queue item sample:
      
      {"requestType":"score","data":{"sourceId":2,"docId":"2000354","sentenceIndex":129,"sentence":"Similarly, an examination of the deep sequencing data depicted in Table S1 in the report by Ruby and coworkers  also shows that miR-84 has 3 main variations.","mentions":[{"id":"3038","type":"gene","value":"has 3"},{"id":"1128","type":"gene","value":"miR"},{"id":"5719","type":"gene","value":"S1"},{"id":"6267","type":"gene","value":"S1"},{"id":"6205","type":"gene","value":"S1"},{"id":"8241","type":"gene","value":"S1"},{"id":"5707","type":"gene","value":"S1"},{"id":"79187","type":"gene","value":"miR"},{"id":"406904","type":"gene","value":"miR"},{"id":"220972","type":"gene","value":"miR"},{"id":"29116","type":"gene","value":"miR"},{"id":"83856","type":"gene","value":"miR"},{"id":"22877","type":"gene","value":"miR"},{"type":"miRNA","value":{"mirna":"hsa-mir-84","origin":"miR-84"}}]}}
      */

      function checkQueue() {
        console.log('checking queue...');
        queueIn.getSingleMessage(function (err, message) {
          if (err) {
            console.error('error getting message from queue', err);
            return setNextCheck();
          }

          if (!message) {
            return setNextCheck();
          }

          return processMessage(message, function (err) {
            if (err) console.error('error processing message:', message.messageid, err);
            
            // move to the next message
            return checkQueue();  
          });
        });
      }
      
      function setNextCheck() {
        setTimeout(checkQueue, queueConfig.checkFrequency);
      };

      function processMessage(message, cb) {
        console.log('new sentence', message);

        var msgObject;
        try {
          msgObject = JSON.parse(message.messagetext);
        }
        catch (err) {
          console.error('error parsing message, invalid json, deleting...', message);
          return deleteMessage(message);
        } 

        var data = msgObject.data && msgObject.data;
        if (!data) {
          console.error('message does not contain data field, deleting...', message);
          return deleteMessage(message);
        }
        
        if (msgObject.requestType !== constants.queues.action.SCORE) {
          console.error('message should not appear in this queue, deleting...', message);
          return deleteMessage(message);
        }
        
        var cache = {};
        var mentions = data.mentions = data.mentions.map(function (mention) {
          // this is a workaround, waiting for Giovanney to fix
          if (!mention.id) mention.id = 1;
          if (typeof mention.value !== 'string') mention.value = 'aaaaa';
          return {
            typeId: constants.conceptTypes[mention.type.toUpperCase()],
            id: parseInt(mention.id),
            name: mention.value
          };
        })
        // filter multiple instance of the same mentions
        // TODO: ask Giovanny to avoid sending multiple instances of the same
        // entities in a sentence
          .filter(function (mention) { 
          var key = mention.typeId + '-' + mention.id;
          if (!cache[key]) {
            cache[key] = 1;
            return mention;
          }
          return null;
        });
        
        if (!mentions || !mentions.length || mentions.length < 2) {
          // we don't have at least two mentions, skip this one
          console.warn('this sentence doesn\'t have at least two mentions, skipping', data);
          return deleteMessage(message);
        }

        // check that we have at least one mirna and one gene
        var genes = data.genes = mentions.filter(function (mention) {
          return mention.typeId === constants.conceptTypes.GENE ? mention : null;
        });
        
        var mirnas = data.mirnas = mentions.filter(function (mention) { 
          return mention.typeId === constants.conceptTypes.MIRNA ? mention : null; 
        });

        if (!genes.length || !mirnas.length) {
            // we don't have one mirna and one gene, skip this one
          console.warn('this sentence doesn\'t have mirna and gene, skipping', data);
          return deleteMessage(message);
        }

        // TODO: implement 
        replaceMentionsWithGenericWords(data);

        // TODO: call scoring API for each combination of mirna/gene (serially)
        // instead of sending one sentence and all of its mentions 

        
        return getScoring(data, function (err, result) {
          // if we had an error getting the scoring for the message,
          // we'll return and hopefully the message will be scored the next
          // time we try...
          if (err) {
            console.error('error getting scoring for message', err);
            return cb(err);
          }
          
          console.log('got scoring relation', result);
          
          if (!result.relations || !result.relations.length) {
            console.warn('scorer didn\'t return relations for sentence', data, result);

            // TODO: what do we want to do in this case? is this an error? 
            // should we delete the message from the queue? should we leave it there for reprocessing?
            return deleteMessage(message);
          }
          
          // make sure all relations are between mirnas and genes
          var mirnaAndGeneRelations = result.relations.filter(function (relation) {
            return  (relation.entity1.typeId === constants.conceptTypes.GENE && relation.entity2.typeId === constants.conceptTypes.MIRNA) ||
                    (relation.entity1.typeId === constants.conceptTypes.MIRNA && relation.entity2.typeId === constants.conceptTypes.GENE);
          });

          if (!mirnaAndGeneRelations.length) {
            console.warn('no relations between mirna and genes', data, result);
            return deleteMessage(message);
          }

          data.entities = genes.concat(mirnas);          
          data.relations = mirnaAndGeneRelations;
          data.modelVersion = result.modelVersion;
          
          // insert relations into db
          return db.upsertRelations(data, function (err) {
            
            // if we had an error inserting into db, we don't want to delete from the queue,
            // just return and hopefully the next iteration will work.
            // the item will stay in the queue until it will be processed.
            if (err) {
              console.error('error updating relation in db', err)
              return cb(err);
            }
            
            // item was processed and saved in db successfully- delete from queue
            return deleteMessage(message, cb);
          });  
        });
        
        function deleteMessage(message) {
          return queueIn.deleteMessage(message, function (err) { 
            if (err) return cb(new Error('error deleting item from queue', err));
            console.log('item deleted from queue', message.messageid);
            return cb();
          });
        }
      };


      function replaceMentionsWithGenericWords(data) {
        // TODO: replace all mentions in the sentences with some kind of a generic random ~10 charachters string.
        // Mapping between names to these generic strings should be consistent in the DB.
        
        return data;
      }

      // TODO: call nadav's
      function getScoring(data, cb) {
        return getScoringFromNadav(data, cb);
        
        console.log('scoring sentence', data);

        var relations = [];
        
        for (var i = 0; i < data.mirnas.length; i++)
          for (var j = 0; j < data.genes.length; j++)
            relations.push({
              entity1: data.mirnas[i],
              entity2: data.genes[j],
              relation: 2,
              score: 0.56
            });

        var result = {
          modelVersion: '0.1.0.1',
          relations: relations
        }
        
        return cb(null, result);
      }
    });
    
     function getScoringFromNadav(data, cb) {
        
        console.log('scoring sentence', data);

        var sentence = data.sentence;
        var relations = [];
        
        var GENERIC_MIRNA = 'MMMIRRRNNAAAA';
        var GENERIC_GENE = 'GGGEEENNNEEEEE';
        
        var genericIndex = 1;
                
        
        for (var i = 0; i < data.mirnas.length; i++)
          for (var j = 0; j < data.genes.length; j++)
            relations.push({
              entity1: data.mirnas[i],
              entity2: data.genes[j]
            });

        async.map(relations,
          function (relation, cb) { 
            
            var generic1 = (relation.entity1.typeId === constants.conceptTypes.GENE ? GENERIC_GENE : GENERIC_MIRNA) + (genericIndex++);
            var generic2 = (relation.entity2.typeId === constants.conceptTypes.GENE ? GENERIC_GENE : GENERIC_MIRNA) + (genericIndex++);
            var text = replace(relation.entity1.name, generic1, sentence)
                        .replace(relation.entity2.name, generic2, sentence);

            console.log('scoring text:', text, 'sentence:', sentence);

            var opts = {
              url: 'http://23.99.7.205/classifyrelation',
              method: 'post',
              json: {
                text: text,
                entity1: generic1,
                entity2: generic2
              }
            };
            return request(opts, function (err, resp, body) {
              console.log('body', body);
              
              if (err) return cb(err);
              if (resp.statusCode !== 200) return cb(new Error('error: statusCode=' + resp.statusCode));
              try {
                
                console.log('scoring', body.scoring);

                var scoring = body.scoring.sort(function (a, b) {
                  return a.score > b.score;
                }).pop();
                
                var result = {
                  modelVersion: data.modelVersion,
                  entity1: relation.entity1,
                  entity2: relation.entity2,
                  class: parseInt(scoring.class),
                  relation: parseInt(scoring.class),
                  score: scoring.score
                }  
              }
              catch (err) {
                return cb(err);
              }
              
              return cb(null, result);
            });

            

            async.setImmediate(function () {
              var result = {
                modelVersion: '0.1.0.1',
                entity1: relation.entity1,
                entity2: relation.entity2,
                class: 2,
                relation: 2,
                score: 0.56
              };
              
              return cb(null, result);
            });
            
          },
          function (err, results) { 
            if (err) return cb(err);
            console.log('finished processing scoring for sentence', results);
            
            var result = {
              modelVersion: '0.1.0.1',
              relations: results
            };
            
            return cb(null, result);
          }
        );
        
        function replace(find, replace, text) {
          var re = new RegExp(find, 'g');
          var res = text.replace(re, replace);
          return res; 
        }
    }
}

module.exports = {
    run: run
}