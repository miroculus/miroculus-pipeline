
var config = require('x-config');
var log = require('x-log');
var path = require('path');
var tedious = require('tedious');
var config = require('x-config');
var queue = require('x-queue');
var db = require('x-db');
var constants = require('x-constants');

var APP_NAME = 'scorer';

function run(cb) {
  cb = cb || Function;

  log.init({
      domain: process.env.COMPUTERNAME || '',
      instanceId: log.getInstanceId(),
      app: APP_NAME,
      level: config.log.level,
      transporters: config.log.transporters
    },
    function (err) {
      if (err) return cb(new Error('Failed to initialize logging, err:', err));
      console.log('starting scoring worker...');

      var queueConfig = {
        storageName: config.storage.account,
        storageKey: config.storage.key,
        queueName: config.queues.scoring,
        checkFrequency: 20000
      };

      var queueIn = queue(queueConfig);
      queueIn.init(function (err) { 
        if (err) return cb(err);
        console.log('start processing scoring queue');
        checkQueue();
      });

      function checkQueue() {
        console.log('checking queue...');
        queueIn.getSingleMessage(function (err, message) {
          if (err) {
            console.error('error getting message from queue', err);
            return setNextCheck();
          }

          if (!message) {
            return setNextCheck();
          }

          return processMessage(message, function (err) {
            if (err) console.error('error processing message:', message.messageid, err);
            
            // move to the next message
            return checkQueue();  
          });
        });
      }
      
      function setNextCheck() {
        setTimeout(checkQueue, queueConfig.checkFrequency);
      };

      function processMessage(message, cb) {
        console.log('new message', message);

        var msgObject;
        try {
          msgObject = JSON.parse(message.messagetext);
        }
        catch (err) {
          console.error('error parsing message, invalid json, deleting...', message);
          return deleteMessage(message);
        } 

        var data = msgObject.data && msgObject.data;
        if (!data) {
          console.error('message does not contain data field, deleting...', message);
          return deleteMessage(message);
        }
        
        if (msgObject.requestType !== constants.queues.action.SCORE) {
          console.error('message should not appear in this queue, deleting...', message);
          return deleteMessage(message);
        }
        
        if (msgObject.requestType === constants.queues.action.SCORE) {

          return getScoring(data, function (err, result) {
            // if we had an error getting the scoring for the message,
            // we'll return and hopefully the message will be scored the next
            // time we try...
            if (err) {
              console.error('error getting scoring for message', err);
              return cb(err);
            }
            
            console.log('got scoring relation:', JSON.stringify(result));
            data.relations = result.relations;
            
            // insert relation into db
            return db.upsertRelations(data, function (err) {

              // if we had error inserting into db, we don't want to delete from the queue,
              // just return and hopefully the next iteration will work.
              // the item will stay in the queue until it will be processed.
              if (err) {
                console.error('error updating relation in db', err)
                return cb(err);
              }
              
              // ite, was processed and saved in db successfully- delete from queue
              return deleteMessage(message, cb);
            });  
          });
          
        }
        
        function deleteMessage(message) {
          return queueIn.deleteMessage(message, function (err) { 
            if (err) return cb(new Error('error deleting item from queue', err));
            console.log('item deleted from queue', message.messageid);
            return cb();
          });
        }
      };

      // TODO: revisit after Justin publishes his API
      function getScoring(data, cb) {
        
        console.log('mor message', data);
        var mentions = data.mentions;
        var m1 = mentions && mentions.length && mentions[0] || {};
        var m2 = mentions && mentions.length && mentions[1] || {};
        
        var result = { 
          relations: [
            {
              entity1: {
                typeId: constants.conceptTypes.MIRNA,
                name: m1.value || 'mirna1'
              },
              entity2: {
                typeId: constants.conceptTypes.GENE,
                name: m2.value || 'gene1'
              },
              relation: 2,
              score: 0.56
            }
          ]
        }

        return cb(null, result);
      }
    });
}

module.exports = {
    run: run
}