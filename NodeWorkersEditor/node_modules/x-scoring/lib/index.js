
var config = require('x-config');
var log = require('x-log');
var path = require('path');
var tedious = require('tedious');
var config = require('x-config');
var queue = require('x-queue');
var db = require('x-db');
var constants = require('x-constants');

var APP_NAME = 'scorer';

function run(cb) {
  cb = cb || Function;

  log.init({
      domain: process.env.COMPUTERNAME || '',
      instanceId: log.getInstanceId(),
      app: APP_NAME,
      level: config.log.level,
      transporters: config.log.transporters
    },
    function (err) {
      if (err) return cb(new Error('Failed to initialize logging, err:', err));
      console.log('starting scoring worker...');

      var queueConfig = {
        storageName: config.storage.account,
        storageKey: config.storage.key,
        queueName: config.queues.scoring,
        checkFrequency: 20000
      };

      var queueIn = queue(queueConfig);
      queueIn.init(function (err) { 
        if (err) return cb(err);
        console.log('start processing scoring queue');
        checkQueue();
      });

      function checkQueue() {
        console.log('checking queue...');
        queueIn.getSingleMessage(function (err, message) {
          if (err) {
            console.error('error getting message from queue', err);
            return setNextCheck();
          }

          if (!message) {
            return setNextCheck();
          }

          return processMessage(message, function (err) {
            if (err) console.error('error processing message:', message.messageid, err);
            
            // move to the next message
            return checkQueue();  
          });
        });
      }
      
      function setNextCheck() {
        setTimeout(checkQueue, queueConfig.checkFrequency);
      };

      function processMessage(message, cb) {
        console.log('new sentence', message);

        var msgObject;
        try {
          msgObject = JSON.parse(message.messagetext);
        }
        catch (err) {
          console.error('error parsing message, invalid json, deleting...', message);
          return deleteMessage(message);
        } 

        var data = msgObject.data && msgObject.data;
        if (!data) {
          console.error('message does not contain data field, deleting...', message);
          return deleteMessage(message);
        }
        
        if (msgObject.requestType !== constants.queues.action.SCORE) {
          console.error('message should not appear in this queue, deleting...', message);
          return deleteMessage(message);
        }
        
        var mentions = data.mentions;
        if (!mentions || !mentions.length || mentions.length < 2) {
          // we don't have at least two mentions, skip this one
          console.warn('this sentence doesn\'t have at least two mentions, skipping', data);
          return deleteMessage(message);
        }

        // check that we have at least one mirna and one gene
        var foundMirna, foundGene;
        for (var i = 0; i < mentions.length; i++) {
          var type = mentions[i].type.toLowerCase();
          if (type === constants.entitiesName.GENE)
            foundGene = true;
          else if (type === constants.entitiesName.MIRNA)
              foundMirna = true;
              
          if (foundMirna && foundGene) {
            break;
          }
        }

        if (!foundMirna && !foundGene) {
            // we don't have one mirna and one gene, skip this one
          console.warn('this sentence doesn\'t have mirna and gene, skipping', data);
          return deleteMessage(message);
        }

        // TODO: implement 
        replaceMentionsWithGenericWords(data);

        // TODO: call scoring API for each combination of mirna/gene (serially)
        // instead of sending one sentence and all of its mentions 


        return getScoring(data, function (err, result) {
          // if we had an error getting the scoring for the message,
          // we'll return and hopefully the message will be scored the next
          // time we try...
          if (err) {
            console.error('error getting scoring for message', err);
            return cb(err);
          }
          
          console.log('got scoring relation:', JSON.stringify(result));
          
          if (!result.relations || !result.relations.length) {
            console.warn('scorer didn\'t return relations for sentence', data, result);

            // TODO: what do we want to do in this case? is this an error? 
            // should we delete the message from the queue? should we leave it there for reprocessing?
            return deleteMessage(message);
          }

          // make sure all relations are between mirnas and genes
          var mirnaAndGeneRelations = result.relations.filter(function (relation) {
            return  (relation.entity1.type === constants.entitiesName.GENE && relation.entity2.type === constants.entitiesName.MIRNA) ||
                    (relation.entity1.type === constants.entitiesName.MIRNA && relation.entity2.type === constants.entitiesName.GENE);
          });

          if (!mirnaAndGeneRelations.length) {
            console.warn('no relations between mirna and genes', data, result);
            return deleteMessage(message);
          }
          
          data.relations = mirnaAndGeneRelations;
          data.modelVersion = result.modelVersion;
          
          // insert relation into db
          return db.upsertRelations(data, function (err) {

            // if we had error inserting into db, we don't want to delete from the queue,
            // just return and hopefully the next iteration will work.
            // the item will stay in the queue until it will be processed.
            if (err) {
              console.error('error updating relation in db', err)
              return cb(err);
            }
            
            // ite, was processed and saved in db successfully- delete from queue
            return deleteMessage(message, cb);
          });  
        });
        
        function deleteMessage(message) {
          return queueIn.deleteMessage(message, function (err) { 
            if (err) return cb(new Error('error deleting item from queue', err));
            console.log('item deleted from queue', message.messageid);
            return cb();
          });
        }
      };


      function replaceMentionsWithGenericWords(data) {
        // TODO: replace all mentions in the sentences with some kind of a generic random ~10 charachters string.
        // Mapping between names to these generic strings should be consistent in the DB.
        
        return data;
      }


      // TODO: revisit after Justin publishes his API
      function getScoring(data, cb) {
        
        console.log('scoring sentence', data);
        var mentions = data.mentions;
        var m1 = mentions[0];
        var m2 = mentions[1];

        // TODO: change to return only one relation 

        var result = { 
          modelVersion: '0.1.0.1',
          relations: [
            {
              entity1: {
                typeId: constants.conceptTypes[m1.type.toUpperCase()] || constants.entitiesName.MIRNA,
                name: m1.value
              },
              entity2: {
                typeId: constants.conceptTypes[m2.type.toUpperCase()] || constants.entitiesName.GENE,
                name: m2.value
              },
              relation: 2,
              score: 0.56
            }
          ]
        }

        return cb(null, result);
      }
    });
}

module.exports = {
    run: run
}